/*
 * mod_signal.c
 * signal module (handle various types of signal)
 * Author: Ayub <ayub@nixtecsys.com>
 */
#include "mod_signal.h"

/* state machine should be developed from received packets */
static void *signal_process(void *s, void *sys)
{
#define MAX_SIGNALS		3
  static struct signalfd_siginfo siginfo[MAX_SIGNALS];
  size_t siginfolen = sizeof(struct signalfd_siginfo) * MAX_SIGNALS;

  int n = 0;
  ssize_t nr = 0;
  int signo = 0;
  int i = 0;

  hook_t *h = s;
  nr = read(h->fd, &siginfo, siginfolen);
  if (nr <= 0) {
    perror("read: signalfd");
    return NULL;
  }
  n = nr / sizeof(struct signalfd_siginfo);
  for (i = 0; i < n; ++i) {
    signo = siginfo[i].ssi_signo;
    DTRACE("Received signal (signo: %u)\n", siginfo[i].ssi_signo);
    switch (signo) {
      case SIGINT:
      case SIGQUIT:
	CRITICAL("\n\n***Interrupted by user, exiting.***\n");
	exit(EXIT_SUCCESS);
	break;
      case SIGHUP:
	CRITICAL("\n\n\t***Toggling Trace***\n\n");
	((system_t *) sys)->__trace_enabled__ ^= 1;
	if (((system_t *) sys)->__trace_enabled__ == 1) {
	  CRITICAL("\n---------- TRACE  ENABLED ----------\n");
	} else {
	  CRITICAL("\n---------- TRACE DISABLED ----------\n");
	}
	break;
      default:
	CRITICAL("Ignored Signal %d\n", signo);
	break;
    }
  }

  return NULL;
}

static void *signal_ready(void *self, void *sys)
{
  void *ret = NULL;
  hook_t *s = self;
  if (CHECKFLAG(s->ev.events, EPOLLRDHUP) ||
      CHECKFLAG(s->ev.events, EPOLLHUP) ||
      CHECKFLAG(s->ev.events, EPOLLERR)
     ) {
    CRITICAL("signalfd got EPOLL{RDHUP|HUP|ERR}. Closing. This should NOT happen.\n");
    close(s->fd);
    ret = NULL;
  } else {
    ret = s;
  }

  return ret;
}


int module_start(system_t *sys)
{
  int fd = -1;
  sigset_t mask;

  int flags = SFD_NONBLOCK | SFD_CLOEXEC;
  sigemptyset(&mask);
  sigfillset(&mask); /* handle all signals */

  /* don't handle these signals, let the process die */
  sigdelset(&mask, SIGFPE);
  sigdelset(&mask, SIGILL);
  sigdelset(&mask, SIGSEGV);

  /* my own preferences for other signals */
  sigdelset(&mask, SIGKILL);
  sigdelset(&mask, SIGSTOP);
  sigdelset(&mask, SIGCONT);

  /* according to POSIX, the behavior of a process is undefined
   * after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that
   * was not generated by kill(2) or raise(3). Integer division
   * by zero has undefined result. On some architectures it will
   * generate a SIGFPE signal.  (Also dividing the most negative
   * integer by -1 may generate SIGFPE.) Ignoring this signal
   * might lead to an endless loop.
   */

  /*
   * POSIX.1-1990 disallowed setting the action for SIGCHLD to SIG_IGN.
   * POSIX.1-2001 allows this possibility, so that ignoring SIGCHLD can be
   * used to prevent the creation of zombies (see wait(2)).  Nevertheless,
   * the historical BSD and System V behaviors for ignoring SIGCHLD
   * differ, so that the only completely portable method of ensuring that
   * terminated children do not become zombies is to catch the SIGCHLD
   * signal and perform a wait(2) or similar.
   */

  /* block signals so that they aren't handled by their default dispositions */
  if (pthread_sigmask(SIG_BLOCK, &mask, NULL) != 0) {
    perror("pthread_sigmask");
    goto err_ret;
  }

  fd = signalfd(-1, &mask, flags);
  if (fd == -1) {
    perror("signlafd");
    goto err_ret;
  }

  hook_t *s = hook_new();
  if (s) {
    s->fd = fd;
    s->data = sys;

    *(&s->ready) = signal_ready;
    *(&s->process) = signal_process;
    s->ev.events = EPOLLIN | EPOLLRDHUP | EPOLLPRI | EPOLLET;
    s->ev.data.ptr = s;
  } else {
    DTRACE("%s:%d\n", __FILE__, __LINE__);
    goto err_ret;
  }

  EVQ_ADD(sys->eventfd, fd, &s->ev);
  return fd;

err_ret:
  if (fd >= 0) close(fd);
  return -1;
}

int module_stop(system_t *sys, module_t *mod)
{
  if (mod && mod->fd > 0) close(mod->fd);
  /*
   * closing the descriptor automatically removes it from the event
  EVQ_DEL(sys->eventfd, mod->fd);
  */
  return 0;
}


